# Vulnerability_assessment_project
리눅스 계열 시스템 취약점 진단 자동화 솔루션 
> 2024.07.04 ~<br>
> ※ sudo 권한으로 실행 해야하며, tree 및 jq 패키지 설치 필요 ※
<div class="notice--primary" markdown="1">
 Ubuntu 8, CentOS 7, Locky Linux8 의 3가지 시스템에 호환됩니다.
</div>

# 프로젝트 개요

```
현재까지 지속되는 보안 위협의 증가와 진화는 계속해서 이루어지고 있다. IT 기술은 끊임 없이 발전하며,
이를 따라서 사이버 공격 기술 또한 시간이 지남에 따라 더욱 정교하고 다양해지고 있다.또한, 아직 알려지지 않거나,
패치되지 않은 0-DAY 취약점이 존재하며, 이러한 취약점 및 서버의 설정 미흡을호 인한 피해를 감소하기 위해 지속적인 취약점 진단이 필요하다.

한번의 실수로 인해 발생하는 사이버 피해는 경제적 손실과 사회적 혼란을 초래하며, 데이터 손시링나 변조는 비즈니스 신뢰도에 큰 타격을 주게된다.
주기적인 취약점 진단은 공격 당하기 전에 데이터를 보호하고 시스템의 안전성을 유지하는 중요한 역할이며, 금융, 의료, 공공기관 등 특정 산업에서는 보안 규정 준수가 법적으로 요구되고 있다.
또한 많은 조직은 보안 감사를 통해 외부로부터의 평가를 받아야한다. 이러한 각각의 문제점을을 파악하여 주기적인 취약점 진단을 수동으로 진단하기에는 무리가 있으며,
진단 요청 클라이언트에게 보다 이해하기 쉽도록 대시보드를 통해 시각화 하면 효율적일거라 생각하여 대시보드를 통한 리눅스 계열에서의 시스템 취약점 진단 자동화 솔루션을 제작하였습니다.
```

# 특징
## 1. Ubuntu 8

```
Ubuntu의 경우 사용하기 쉬운 인터페이스와 광범위한 커뮤니티 지원을 하며, 안정성과 보안 업데이트가 꾸준히 된다.
이러한 이유로 서버 관리가 단순화되어 기업에서 인프라를 유지하는데 도움이되어 규모가 작은 스타트업, 
중소기업에서는 Ubuntu 를 서버로 사용하고 있어 선택하였습니다.
```

## 2. CentOS 7

```
기존의 많은 레거시 시스템은 CentOS 7을 서버로 사용하고 있으며, Red Had Enterprise Linux와 호환성이 매우 높아 RHEL 기반의
엔터프라이즈급 안전성과 보안 기능을 그대로 이용할 수 있어 많은 기업들이 안정적인 서버 환경을 위해 사용하고 있으며,
특히 금융, 통신, 제조업등에서 많이 사용되어 선택하였습니다.
```

## 3. Rocky Linux 8

```
CentOS 7,8의 지원 종료 이후 대안으로 Rocky Linux가 등장하였으며, RHEL과 완벽하게 호환되며,
CentOS를 사용하던 많은 기업들이 안정적으로 전환할 수 있도록 지원하여 현재 많은 기업들이 Rocky Linux로 전환하고 있으며,
기업환경에서 필요한 LTS와 보안 업데이트를 지원하며, 완전한 오픈 소스, 커뮤니티 중심으로 개발이 이루어지며,
금융, 의료, 공공기관가 같은 분야에서 사용되고 있어 선택하였습니다.

이러한 이유들로 3개의 리눅스 계열의 시스템을 진단하도록 스크립트를 작성하였으며, 각각의 위험도를 나눠 High, Mid, Low 단계로 나눠
점검결과 및 상세정보, 계정관리, 파일 및 디렉터리 관리, 서비스 관리, 패치 관리, 로그관리와 같이 특정 점검 분야에 대해서도
진단 결과를 도출하여 대시보드를 통해 표와 차트를 이용하여 진단 요청 클라이언트에게 시각화된 진단 결과를 전달 함으로써,
좀 더 진단 결과를 빠르게 파악할 수 있도록 제작하였습니다.
```

# 기술 스택

![Shell Script](https://img.shields.io/badge/Shell_Script-ffd700?style=flat-square&logo=Linux&logoColor=black)<br>
![HTML5](https://img.shields.io/badge/HTML5-ff6347?style=flat-square&logo=HTML5&logoColor=white)<br>
![CSS3](https://img.shields.io/badge/CSS3-1e90ff?style=flat-square&logo=CSS3&logoColor=white)<br>
![JavaScript](https://img.shields.io/badge/JavaScript-ffd700?style=flat-square&logo=javascript&logoColor=black)<br>
![Node JS](https://img.shields.io/badge/Node.JS-adff2f?style=flat-square&logo=node.js&logoColor=white)<br>
![MongoDB](https://img.shields.io/badge/MongoDB-228b22?style=flat-square&logo=mongodb&logoColor=black)

# 프로젝트 구조

```
각각의 시스템에 해당되는 스크립트를 해당 서버에서 실행시 진단 결과를 담은 값들이 자동으로 웹 서버로 전송되며,
해당 값들은 Mongo DB에 저장되어, 차트, 표를 통해 클라이언트에게 시각적으로 전달됩니다.
해당 저장된 내용은 삭제 버튼을 통해 Data Base에서 즉시 삭제되므로, 귀사의 시스템 정보는 진단 일시를 제외한 어떠한 순간에도 저장하지 않습니다.
```

# 프로젝트중 에로사항 및 문제 해결
### 1. 각 배포판별 상이한 명령어, 파일 경로

```
각각의 배포판별로 조금씩 상이한 명령어와 파일 경로가 존재하여, 이를 찾아가며, 존재 여부 및 기본 설정값을 확인하여 스크립트 제작
```

### 2. 파일 내에 주석, 공백, 대/소문자로 인한 파일 내 출력값 경우의 수

```
스크립트 제작 후 여러 경우의 수를 대입하며, 지속적인 스크립트를 수정함.
주석, 공백, 대/소문자로 인해 확인해야하는 설정값들이 정상적으로 추출되지 않아 여러 경우의수를 대입하며 수정해나감
```

### 3. 웹 서버로 전송되는 리턴 값

```
진단 후 각각의 경우의 진단 결과가 웹 서버로 전달되어 Mongo DB에 저장되어야 하므로,
각 진단 항목에 대한 리턴값을 수정하여 웹 페이지에 렌더링 할 수 있었음
```

### 4. 중복 변수 사용으로 인한 에러

```
수많은 항목을 하나의 스크립트로 작성하다 보니, 중복된 값들이 존재, 이를 해결하기 위해 각 항목 코드를 변수 앞에 생성하여 해결함
```

# 성과 및 결과

```
주요정보통신기반 시설 취약점진단의 72가지 항목에 대해 진단한 결과가 웹 대시보드에서 표와 차트를 통해 시각적으로 표현되어,
진단 요청 클라이언트에게 보다 쉽게 설명이 가능하게 됨.

단순 진단 후 클라이언트에게 전달할 때 요청 클라이언트는 보안에 대한 지식이 그닥 많지 않을 경우가 있다.
이 때 어떤 항목에서 어떤 취약점이 발견됐고 왜 위험하고, 어떤 값들이 어떻게 설정되어 있다를 단순 말과 스크립트의 결과로
 전달하는것은 전달에 한계가 있다고 생각하여시각적으로 표현하고자 진행한 프로젝트가 많은 시행착오가 있었지만,
해당 프로젝트를 진행하며, 클라이언트 입장에서 이해하기 어떤 부분을 수정해야하고 어떤 부분이 서버에 피해가 가는지 조금이나마 이해할 수 있을거래 생각됐다.
 또한 해당 스크립트 제작시 평소 사용하지 않던 명령어와, 그에 해당하는 옵션들에 대한 사용법을 익히게 되어 만족스러운 프로젝트였다.
```

# 추후 계획 및 개선 사항

```
더 많은 배포판과 클라우드, 윈도우, 네트워크 장비에 대한 자동화된 취약점 진단 스크립트와, 원격 진단 스크립트를 제작할 예정입니다.
```

# 결론

# 시연 및 데모
![image](https://github.com/user-attachments/assets/6a9bc303-15e9-4442-ba08-c42bf38fe234)
![image](https://github.com/user-attachments/assets/c783a2af-0f9d-41b6-8956-5a7f5c21d954)


- 로그인이 이루어져야 대시보드 사용이 가능하도록 구현,
- 회원 가입시 ID, PW, Email, Serail_Number 을 입력하도록 구현

![image](https://github.com/user-attachments/assets/f0c7f395-42cd-4ce2-b5d6-469b8a5e50e1)

- Users 컬렉션에 저장되며, 각각 필요에 맞는 컬렉션들을 생성해놓음

![image](https://github.com/user-attachments/assets/a7b3b816-b078-43c6-9389-2fbf064728e9)

- 로그인 성공 후 대시보드가 출력되며, 점검 전에는 아무런 내용이 출력되지 않는 걸 볼 수 있음.
  
![image](https://github.com/user-attachments/assets/6cef482d-0763-479f-9a27-cbcee1a3bcc3)

![image](https://github.com/user-attachments/assets/eb1b56b8-f51d-4763-86b9-fc8c82b0b30e)
- 해당 대시보드에서 3가지의 리눅스 배포판에 대한 점검 스크립트를 다운받을 수 있음

### 점검 스크립트 일부
```
cat << EOF
===== [U-01] Remote Login Permission for the root User  =====
=====                  Chaking...........               =====
EOF
	
echo "--------------------------------------------------------------------------" >> $target
echo "                        U-01 [위험도 상] root 계정 원격 접속 제한                         "  >> $target
echo "--------------------------------------------------------------------------" >> $target
echo "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" >> $target
echo "점검목적 : 관리자계정 탈취로 인한 시스템 장악을 방지하기 위해 외부 비인가자의 root 계정 접근 시도를 원천적으로 차단하기 위함" >> $target
echo "보안위협 : root 계정은 운영체제의 모든기능을 설정 및 변경이 가능하여(프로세스, 커널변경 등) root 계정을 탈취하여 외부에서 원격을 이용한 시스템 장악 및 각종 공격으로(무작위 대입 공격) 인한 root 계정 사용 불가 위협" >> $target
echo "+판단기준 양호 🔘: 원격 터미널 서비스를 사용하지 않거나, 사용 시 root 직접 접속을 차단한 경우" >> $target
echo "+판단기준 취약 🚫: 원격 터미널 서비스 사용 시 root 직접 접속을 허용한 경우" >> $target
echo "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" >> $target
echo "" >> $target
echo "-------------" >> $result
echo "U-1 점검 결과" >> $result
u1=0
u1_safe_check=0
u1_Account_Management=0

telnet_access_check() {
    if [ -f "/etc/securetty" ]; then
        echo "/etc/securetty 파일: 존재함" >> "$target"
        if grep -q "pts" "/etc/securetty"; then
            u1_safe_check=$((u1_safe_check+1))
        else
            echo "pts 항목: 발견되지 않음">> "$target"
        fi
    else
        echo "/etc/securetty 파일이 존재하지 않습니다." >> "$target"
    fi
    
    if [ -f "/etc/pam.d/login" ]; then
        echo "/etc/pam.d/login 파일이 존재합니다." >> "$target"
        if grep -qiE "^\s*#\s*auth\s*required\s*/lib/security/pam_securetty.so" "/etc/pam.d/login"; then
            echo "auth required /lib/security/pam_securetty.so 항목이 주석처리 되어 있습니다." >> "$target"
            u1_safe_check=$((u1_safe_check+1))
        else
            if grep -qiE "^\s*auth\s*required\s*/lib/security/pam_securetty.so" "/etc/pam.d/login"; then
                echo "auth required /lib/security/pam_securetty.so 항목: 발견됨" >> "$target"
            else
                echo "auth required /lib/security/pam_securetty.so 항목: 비활성화" >> "$target"
                u1_safe_check=$((u1_safe_check+1))
            fi
        fi
    else
        echo "/etc/pam.d/login 파일이 존재하지 않습니다." >> "$target"
    fi
    if [[ $u1_safe_check -ge 1 ]];then
        echo "점검 결과 : 취약" >> $result
        u1=$((u1+1)) 
    else
        echo "점검 결과 : 양호" >> $result
    fi
}
if pgrep "telnetd" > /dev/null; then
    echo "Telnet 서비스: 동작 중"
    telnet_access_check	
else
    if grep -q '^telnet[[:space:]]*23/tcp' /etc/services; then
        if netstat -tuln | grep :23  > /dev/null; then
            telnet_access_check
        else
	    echo 'telnet 프로세스: 동작 중이 아님' >> $target
        fi
    else
        echo 'telnet 기본 포트 23으로 설정되어있지 않음' >> $target
        u1_telnet_newport=$(grep '^telnet[[:space:]]' /etc/services | awk '{print $2}' | cut -d'/' -f1)
        if netstat -tuln | grep :$u1_telnet_newport  > /dev/null; then
            telnet_access_check
        else
	    echo 'telnet 프로세스: 동작 중이 아님' >> $target
        fi
    fi
fi
ssh_access_check() {
    # /etc/ssh/sshd_config 파일 체크
    if [ -f "/etc/ssh/sshd_config" ]; then
        echo "/etc/ssh/sshd_config 파일: 존재함" >> "$target"
        if grep -iqE "^\s*#\s*PermitRootLogin" "/etc/ssh/sshd_config"; then
            echo "PermitRootLogin 항목이 주석처리 되어있습니다. : 비활성화" >> "$target"
            u1_safe_check=$((u1_safe_check+1))
        else
            if grep -iE '^\s*PermitRootLogin' "/etc/ssh/sshd_config" | awk '{print tolower($2)}' | grep -iq 'yes'; then
                echo "  - PermitRootLogin Yes : 발견됨" >> "$target"
                u1_safe_check=$((u1_safe_check+1))
            else
                echo "  - PermitRootLogin Yes : 발견되지 않음 " >> "$target"
            fi
        fi
    else
        echo "/etc/ssh/sshd_config 파일: 존재하지 않음" >> "$target"
    fi

    # /etc/pam.d/sshd 파일 체크
    if [ -f "/etc/pam.d/sshd" ]; then
        echo "/etc/pam.d/sshd 파일: 존재함" >> "$target"
        if grep -qiE "^\s*#\s*auth\s*required\s*pam_securetty.so" "/etc/pam.d/sshd"; then
            echo "pam_securetty.so 모듈 사용이 주석처리되어있습니다. : 비활성화" >> "$target"
            u1_safe_check=$((u1_safe_check+1))
        else
            if grep -qiE "^\s*auth\s*required\s*pam_securetty.so" "/etc/pam.d/sshd"; then
                echo "pam_securetty.so 모듈을 사용하고 있습니다." >> "$target"
            else
                echo "pam_securetty.so 모듈을 사용하지 않고 있습니다." >> "$target"
                u1_safe_check=$((u1_safe_check+1))
            fi
        fi

        if grep -qiE "^\s*#\s*AllowUsers" "/etc/pam.d/sshd"; then
            echo "AllowUsers 항목은 주석처리 되어 비활성화 되어 있습니다." >> "$target"
        else
            if grep -qiE "^\s*AllowUsers" "/etc/pam.d/sshd"; then
                if grep -qiE "\s*AllowUsers\s*root" "/etc/pam.d/sshd"; then
                    echo "AllowUsers 항목에 root가 설정되어 있습니다." >> "$target"
                    u1_safe_check=$((u1_safe_check+1))
                else
                    echo "AllowUsers 항목이 안전하게 설정되어 있습니다." >> "$target"
                fi
            else
                echo "AllowUsers 항목이 존재하지 않습니다." >> "$target"
            fi
        fi

        if grep -qiE "^\s*#\s*AllowGroups" "/etc/pam.d/sshd"; then
            echo "AllowGroups 항목은 주석처리 되어 비활성화 되어 있습니다." >> "$target"
        else
            if grep -qiE "^\s*AllowGroups" "/etc/pam.d/sshd"; then
                if grep -qiE "\s*AllowGroups\s*root" "/etc/pam.d/sshd"; then
                    echo "AllowGroups 항목에 root가 설정되어 있습니다." >> "$target"
                    u1_safe_check=$((u1_safe_check+1))
                    echo "AllowGroups 항목이 안전하게 설정되어 있습니다." >> "$target"
                fi
            else
                echo "AllowGroups 항목이 존재하지 않습니다." >> "$target"
            fi
        fi
    else
        echo "/etc/pam.d/sshd 파일 : 존재하지 않음" >> "$target"
    fi
    if [[ $u1_safe_check -ge 1 ]];then
        echo "점검 결과 : 취약" >> "$result"
        u1=$((u1+1)) 
        
    else
        echo "점검 결과 : 양호" >> "$result"
    fi
}
if pgrep "sshd" > /dev/null; then
    echo "sshd 프로세스: 동작 중" >> $target
    ssh_access_check
else
    if grep -q '^ssh[[:space:]]*22/tcp' /etc/services; then
    	if netstat -tuln | grep :22  > /dev/null; then
    	    ssh_access_check
    	else
    	    echo "sshd 프로세스: 동작 중이 아님" >> $target
    	fi
    else
        echo 'ssh 기본 포트 22으로 설정되어있지 않음' >> $target
        u1_ssh_newport=$(grep '^sshd[[:space:]]' /etc/services | awk '{print $2}' | cut -d'/' -f1)
        if netstat -tuln | grep :$u1_ssh_newport  > /dev/null; then
            ssh_access_check	    
    	else
    	    echo "sshd 프로세스: 동작 중이 아님" >> $target
    	fi
    fi
fi

if [ $u1 -ge 1 ];then
    High=$((High+1))
    Account_Management=$((Account_Management+1))
    u1_Account_Management=1
fi
```

```
cat << EOF
===== [U-35] Removing a Web Service Directory Listing              =====
=====                  Chaking...........               =====
EOF
echo "--------------------------------------------------------------------------" >> $target
echo "                        U-35 웹서비스 디렉토리 리스팅 제거              " >> $target
echo "--------------------------------------------------------------------------" >> $target
echo "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" >> $target
echo "+점검목적 : 외부에서 디렉터리 내의 모든 파일에 대한 접근 및 열람을 제한함을 목적으로 함" >> $target
echo "+보안위협 : 디렉터리 검색 기능이 활성화 되어 있을 경우, 사용자에게 디렉터리내 파일이 표시되어 WEB 서버 구조 노출뿐만 아니라 백업 파일이나 소스파일, 공개되어서는 안되는 파일 등이 노출 가능함" >> $target
echo "+판단기준 양호 🔘: 디렉터리 검색 기능을 사용하지 않는 경우" >> $target
echo "+판단기준 취약 🚫: 디렉터리 검색 기능을 사용하는 경우" >> $target
echo "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" >> $target
echo "" >> $target
echo "-------------" >> $result
echo "U-35 점검 결과" >> $result
u35=0
u35_Service_Management=0
u35_safe_check=0
u35_apache_files=("/etc/httpd/conf.d/*.conf" "/etc/httpd/sites-available/*.conf" "/etc/httpd/sites-enabled/*.conf")
u35_nginx_files=("/etc/nginx/conf.d/*.conf")
u35_idx=0
u35_idxn=0
u35_apache_home_checks=("httpd.conf" "apache2.conf" ".htaccess")
u35_break=0
echo "※Cent OS 7 기준 Apache 메인 설정파일 경로와 Nginx 메인 설정 파일인 /etc/nginx/nginx.conf를 점검합니다. 해당 경로가 존재하지 않을 경우, 아파치 웹 서비스 구성 파일명을 토대로 파일 탐색 후 점검이 진행됩니다. 중복된 파일명이 존재할 경우 수동 점검을 권장합니다.※"  >> $target
for u35_apache_home_check in "${u35_apache_home_checks[@]}";do
    u35_apache_home=$(find / -type f -name "$u35_apache_home_check" 2> /dev/null | egrep -v "tmp|temp|swap|swp")
    if [ -f "$u35_apache_home" ];then
        echo "$u35_apache_home 파일이 존재합니다." >> $target
        u35_dir_lisconfs_a=($(grep -vE "^\s*#" "$u35_apache_home" | sed -n '/<Directory/,/<\/Directory>/p' | grep -i "^\s*options" | grep -i indexes | awk '{print $1}' ))
        u35_check_dirpath_a=($(grep -vE "^\s*#" "$u35_apache_home" | awk 'BEGIN { inBlock = 0; block = "" }/<Directory/ {block = $0;inBlock = 1;dirPath = $2; gsub("\"", "", dirPath)}/<\/Directory>/ {block = block "\n" $0;inBlock = 0;if (block ~ /Indexes/) { print dirPath }block = ""}inBlock && ! /<\/Directory>/ { block = block "\n" $0 }' | tr -d '>'))
        for u35_dir_lisconf_a in "${u35_dir_lisconfs_a[@]}";do
            if [ -n $u35_dir_lisconf_a ];then
                echo "웹 서비스 디렉토리 리스팅이 활성화 있습니다." >> $target
                echo "디렉토리 리스팅이 활성화된 디렉토리 경로 : ${u35_check_dirpath_a[$u35_idx]}" >> $target
                u35_safe_check=$((u35_safe_check+1))
                u35_idx=$((u35_idx+1))
            else
                echo "웹 서비스 디렉토리 리스팅이 비활성화 되어 있습니다" >> $target
                echo "디렉토리 리스팅이 비활성화된 디렉토리 경로 : ${u35_check_dirpath_a[$u35_idx]}" >> $target
                u35_idxn=$((u35_idxn+1))
            fi
        done
        break
    else
        u35_idx=0
        if [[ $35_break -eq 1 ]];then
            break
        fi
        u35_break=$((u35_break+1))
        for u35_apache_file in "${u35_apache_files[@]}";do
            for u35_apache_check in $u35_apache_file;do
                if [ -f "$u35_apache_check" ];then
                    u35_adected_filecks=$(grep -vE "^\s*#" "$u35_apache_check" | grep -iw "options" | grep -iw "indexes" | grep -iwv "\-indexes" )
                    for u35_adected_fileck in "${u35_adected_filecks[@]}";do
                        if [[ -n "$u35_adected_fileck" ]];then
                            echo "$u35_apache_check 파일에서 디렉토리 리스팅을 허용하는 indexes 설정값이 존재합니다." >> $target
                            echo "디렉토리 리스팅이 활성화된 디렉토리 경로 : ${u35_check_dirpath_a[$u35_idx]}" >> $target
                            u35_safe_check=$((u35_safe_check+1))
                            u35_idx=$((u35_idx+1))
                        else
                            echo "$u35_apache_check 파일은 존재하지만 디렉토리 리스팅을 허용하는 indexes 설정값이 존재하지 않습니다." >> $target
                            u35_idxn=$((u35_idxn+1))
                        fi
                    done
                fi
            done
        done
        u35_idx=0
    fi
done
echo "추가적인 Apache 웹 서비스 구성 파일들이 존재하지 않습니다. 추가적인 수동 점검을 권장합니다." >> $target
u35_idx=0
u35_idxn=0
if [ -f "/etc/nginx/nginx.conf" ];then
    echo "/etc/nginx/nginx.conf 파일이 존재합니다." >> $target
    u35_dir_lisconfs_n=($(grep -vE "^\s*#" "/etc/nginx/nginx.conf" | grep -iw "^\s*autoindex" | sed 's/^[ \t]*//' | awk '{print tolower($2)}' | tr -d ';'))
    for u35_dir_lisconf_n in "${u35_dir_lisconfs_n[@]}";do
        if [[ $u35_dir_lisconf_n == "on" ]];then
            u35_safe_check=$((u35_safe_check+1))
            u35_idx=$((u35_idx+1))
        else
            u35_idxn=$((u35_idxn+1))
        fi
    done
    echo "웹 서비스 디렉토리 리스팅이 활성화 있습니다." >> $target
    echo "설정 값 : $u35_dir_lisconf_n" >> $target
    echo "총 $u35_idx 개의 취약한 on 설정이 존재합니다. /etc/nginx/nginx.conf 파일을 확인하십시오." >> $target
    echo "웹 서비스 디렉토리 리스팅이 비활성화된 $u35_idxn 개의 안전한  off 설정이 존재 합니다. /etc/nginx/nginx.conf 파일을 확인하십시오." >> $target
else 
    echo "/etc/nginx/nginx.conf 파일이 존재하지 않으며, 웹 서비스 구성 파일명을 토대로 점검을 진행합니다." >> $target
    for u35_ngnix_file in ${u35_nginx_files[@]};do
        for u35_nginx_check in $u35_ngnix_file;do
            u35_dir_lisconfs_n=($(grep -vE "^\s*#" "$u35_nginx_check" 2> /dev/null | grep -iw "^\s*autoindex" | sed 's/^[ \t]*//' | awk '{print tolower($2)}' | tr -d ';'))
            if [ -f "$u35_nginx_check" ];then
                #u35_ndected_filecks=$(grep -vE "^\s*#" "$u35_nginx_check" | grep -iw "autoindex" | tr -d ';' | grep -iw "on")
                for u35_dir_lisconf_n in "${u35_dir_lisconfs_n[@]}";do
                    if [ -n "$u35_dir_lisconf_n" ];then
                        if [ "$u35_dir_lisconf_n" == "on" ];then
                            u35_safe_check=$((u35_safe_check+1))
                            u35_idx=$((u35_idx+1))
                        else
                            u35_idxn=$((u35_idxn+1))
                        fi
                    else
                        echo "$u35_nginx_check 파일은 존재하지만 디렉토리 리스팅을 허용하는 autoindex 설정값이 존재하지 않습니다." >> $target
                        u35_idxn=$((u35_idxn+1))
                    fi
                done
                if [[ $u35_idx -ge 1 ]];then
                    echo "$u35_nginx_check 파일에서 디렉토리 리스팅이 허용되어 있습니다." >> $target
                    echo "설정 값 : $u35_dir_lisconf_n" >> $target
                    echo "총 $u35_idx 개의 취약한 on 설정이 존재합니다. $u35_nginx_check 파일을 확인하십시오." >> $target
                    echo "웹 서비스 디렉토리 리스팅이 비활성화된 $u35_idxn 개의 안전한  off 설정이 존재 합니다. $u35_nginx_check 파일을 확인하십시오." >> $target
                fi
            fi
        done
    done
    echo "추가적인 웹 서비스 구성 파일들이 존재하지 않습니다. 추가적인 수동 점검을 권장합니다." >> $target
fi
if [[ $u35_safe_check -ge 1 ]];then
    u35=$((u35+1))
    echo "점검 결과 : 취약" >> $result
else
    echo "점검 결과 : 양호" >> $result
fi
if [[ $u35 -ge 1 ]];then
    High=$((High+1))
    Service_Management=$((Service_Management+1))
    u35_Service_Management=1
fi
```
```
check_service_status() {
    local port_numbers=("$1")  # 첫 번째 인자는 포트 번호 배열 또는 단일 포트 번호
    shift  # 첫 번째 인자를 제거하고 나머지 인자들을 서비스 이름으로 설정

    local services=("$@")  # 나머지 인자를 배열에 저장
    local any_service_active=0  # 플래그 초기화

    for i in "${!services[@]}"; do
        local service_name=${services[$i]}
        local port_number=${port_numbers[$i]:-0}  # 포트 번호가 없으면 기본값 0

        echo "Checking $service_name..." >> "$target"

        # 서비스 활성화 여부 체크
        if systemctl is-active --quiet "$service_name"; then
            echo "현재 시스템에 $service_name 서비스가 활성화 되어 있습니다. 불필요한 경우 비활성화가 이루어져야 합니다." >> "$target"
            any_service_active=1  # 플래그를 1로 설정
        else
            echo "현재 시스템에 $service_name 서비스가 비활성화 되어 있습니다." >> "$target"
        fi

        # 네트워크 포트 체크
        local netstat_ports=$(netstat -tuln | awk '{print $4}' | awk -F':' '{print $2}')

        if [ $port_number -ne 0 ] && echo "$netstat_ports" | grep -qE "^$port_number$"; then
            echo "$service_name 서비스가 $port_number 포트번호로 설정되어 있습니다." >> "$target"
            echo "$service_name 서비스가 $port_number 번 포트번호로 서비스가 동작중입니다." >> "$target"
        else
            local new_port=$(grep -wE "^$service_name\s+" /etc/services | awk '{print $2}' | awk -F'/' '{print $1}' | head -n 1)
            if [ -n "$new_port" ]; then
                echo "$service_name 서비스가 $new_port 포트번호로 설정되어 있습니다." >> "$target"
                if echo "$netstat_ports" | grep -qE "^$new_port$"; then
                    echo "$service_name 서비스가 $new_port 포트번호로 서비스가 동작중입니다." >> "$target"
                else
                    echo "$service_name 서비스가 $new_port 포트번호로 동작중인 서비스가 없습니다." >> "$target"
                fi
            else
                echo "$service_name 서비스가 /etc/services 파일에 정의되어 있지 않습니다." >> "$target"
            fi
        fi

        # inetd 서비스 체크
        if [ -f "/etc/inetd.conf" ]; then
            if grep -qiwE "^\s*$service_name" /etc/inetd.conf; then
                echo "/etc/inetd.conf 파일에서 $service_name 서비스가 활성화 되어 있습니다." >> "$target"
            else
                echo "/etc/inetd.conf 파일에서 $service_name 서비스가 비활성화 되어 있습니다." >> "$target"
            fi
        else
            echo "/etc/inetd.conf 파일이 존재하지 않습니다." >> "$target"
        fi

        # xinetd 서비스 체크
        if [ -d "/etc/xinetd.d" ]; then
            if [ -f "/etc/xinetd.d/$service_name" ]; then
                local xinetd_conf=$(grep -iE "\s*disable" "/etc/xinetd.d/$service_name" | grep -v "^#" | awk '{print $3}' | head -n 1)
                if [[ "$xinetd_conf" == "no" ]]; then
                    echo "/etc/xinetd.d/$service_name 파일내에 $service_name 항목이 활성화 되어 있습니다." >> "$target"
                else
                    echo "/etc/xinetd.d/$service_name 파일내에 $service_name 항목이 비활성화 되어 있습니다." >> "$target"
                fi
            else
                echo "/etc/xinetd.d/$service_name 파일이 존재하지 않습니다." >> "$target"
            fi
        else
            echo "/etc/xinetd.d 디렉터리가 존재하지 않습니다." >> "$target"
        fi

        echo "Finished checking $service_name." >> "$target"
        echo "" >> "$target"  # 빈 줄 추가
    done

    # 동작 중인 서비스가 하나라도 있으면 1을 출력
    if [ $any_service_active -eq 1 ]; then
        return 1
    else
        return 0
    fi
}
```

![image](https://github.com/user-attachments/assets/623d99aa-eb6e-4e61-b8ef-786cfbfdd28f)
- 다운로드 받은 점검 스크립트를 점검 대상 시스템에서 sudo 권한과 함께 실행

![image](https://github.com/user-attachments/assets/f277de44-69e0-4839-86ef-5a979ff951ab)
- 점검이 완료될 경우 사진과 같이 출력됨. 서버 상에서도 점검 파일을 확인할 수 있음

![image](https://github.com/user-attachments/assets/537eadee-e0aa-4245-b8ea-dcf568560f96)
- 대시보드에서 점검 결과를 표와 차트를 통해 확인 가능하며 각 항목에 대한 점검 결과 계정 관리 ,파일 및 디렉터리 관리, 서비스 관리, 패치 관리, 로그 관리에 대해 분류하여  취약으로 판단된 항목들 을 출력
- 점검 결과에 대한 자세한 내용과 각 항목에 대한 취약/양호 결과가 담긴 2개의 파일을 다운받아 확인할 수 있음
- 세션값은 10분으로 유지됨
- 점검 및 확인이 끝나면 "대시보드 초기화" 를 통해 점검결과에 대한 모든 정보가 초기화 되어 기업의 정보시스템자산 취약점 식별 현황을 저장하지 않고 전부 삭제함

<br><br><br>
<hr>
<br><br><br>

<div class="notice--primary" markdown="1">
 © 2024 이규혁(Lee GyuHyeok) All rights reserved.<br>
  해당 프로젝트에서 사용된 코드는 상업적인 이유를 제외하고 사용이 가능하며, 사용시 해당 코드의 출처를 명시하여야 합니다.
  해당 코드는 악용을 금하고 있으며, 해당 코드를 악용하여 발생하는 모든 책임은 본인에게 있습니다.
</div>
