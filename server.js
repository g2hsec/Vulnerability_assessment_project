//express 라이브러리 사용
const express = require('express')
const app = express() 
const bodyParser = require('body-parser')
const path = require('path')
const fs = require('fs'); 
const multer = require('multer'); 
const session = require('express-session')
const passport = require('passport')
const LocalStrategy = require('passport-local')
const dataMappingPath = path.join(__dirname, 'dataMapping.json');
const bcrypt = require('bcrypt')
const MongoStore = require('connect-mongo')

let dataMapping;
fs.readFile(dataMappingPath, 'utf8', (err, data) => {
    if (err) {
        console.error('Error reading data mapping file:', err);
        return;
    }
    dataMapping = JSON.parse(data);
});

app.use(passport.initialize())
app.use(session({
  secret: 'encryption',
  resave : false,
  saveUninitialized : false,
  cookie : { maxAge : 60 * 60 * 1000 },
  store : MongoStore.create({
    mongoUrl : 'mongodb+srv://g2h:admin@cluster0.sa7g1pd.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0',
    dbName : 'system_assessment'
  })
}))

app.use(passport.session()) 
app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());
//app.use(express.static(__dirname + '/public'))
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
      cb(null, 'uploads/');
    },
    filename: (req, file, cb) => {
      cb(null, file.originalname);
    }
  });
const upload = multer({ storage: storage });
app.use(express.static(path.join(__dirname, 'public')));
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));
//ejs 설정
app.set('view engine', 'ejs')

const { MongoClient, ObjectId } = require('mongodb'); // MongoClient를 가져오는 부분 추가 + ObjectId 불러오기
let db;
const url = 'mongodb+srv://g2h:admin@cluster0.sa7g1pd.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0';

const ScriptFolder = path.join(__dirname, "Scripts")
const result_ScriptFolder = path.join(__dirname, "uploads")
app.use(express.static("ScriptFolder"))
app.use(express.static("result_ScriptFolder"))

new MongoClient(url).connect().then((client) => {
    console.log('DB 연결 성공');
    db = client.db('system_assessment');
    app.listen(8080, () => {
        console.log("로컬호스트에서 서버 실행중")
    })
}).catch((err) => {
    console.log('DB 연결 실패:', err);
});

// Local Strategy 설정
passport.use(new LocalStrategy(async (username, password, cb) => {
    try {
      let user = await db.collection('Users').findOne({ username: username });
      
      if (!user) {
        return cb(null, false, { message: '아이디가 DB에 없습니다.' });
      }
      
      //await bcrypt.compare(password, user.password)
      if (await bcrypt.compare(password, user.password)) {
        return cb(null, user);
      } else {
        return cb(null, false, { message: '비밀번호가 일치하지 않습니다.' });
      }
    } catch (err) {
      return cb(err);
    }
}))

// 사용자 정보를 세션에 저장
passport.serializeUser((user, done) => {
    process.nextTick(() => { //내부 코드를 비동기적으로 처리
        done(null, { id : user._id, username : user.username })
    })
})

// 세션에서 사용자 정보 복원
passport.deserializeUser(async (userData, done) => {
    try {
        let user = await db.collection('Users').findOne({ _id: new ObjectId(userData.id) });
        delete user.password; // password 속성 제거
        done(null, user);
    } catch (err) {
        done(err);
    }
});

// 미들웨어를 사용하여 로그인 상태에 따라 다른 템플릿 렌더링
// 사용자 정보를 res.locals에 저장하는 미들웨어 
app.use((req, res, next) => {
    res.locals.isAuthenticated = req.isAuthenticated();
    res.locals.user = req.user; // 사용자 정보를 res.locals.user에 저장

    next();
});

function ensureAuthenticated(req, res, next) {
    if (req.isAuthenticated()) {  // 인증된 경우
        return next();  // 요청을 다음 미들웨어로 넘김
    } else {
        res.redirect('/login');  // 인증되지 않은 경우 로그인 페이지로 리다이렉션
    }
}


app.get('/', (req, res) => {
    if (req.isAuthenticated()) {
        res.redirect('/inspection_results'); 
      } else {
        res.redirect('/login'); 
    }
})

app.get('/inspection_results', ensureAuthenticated, async (req, res) => {
    try {
        let Severity = await db.collection('Severity').find().toArray();
        let Inspection_Items = await db.collection('Inspection_Items').find().toArray();
        let system_info = await db.collection('system_info').find().toArray();
        let files = fs.readdirSync(ScriptFolder);
        let result_files = fs.readdirSync(result_ScriptFolder);

        let tab1Items = await db.collection('Account_Management').find().toArray();
        let tab2Items = await db.collection('Files_Directory_Management').find().toArray();
        let tab3Items = await db.collection('Service_Management').find().toArray();
        let tab4Items = await db.collection('Patch_Management').find().toArray();
        let tab5Items = await db.collection('Log_Management').find().toArray();
        //console.log(tab1Items.u2_Account_Management)
        let tab1Fields = tab1Items.map(item => item.title); // title만 추출
        //console.log('tab1Fields:', tab1Fields); // 서버 로그에 출력 확인
        let tab2Fields = tab2Items.map(item => item.title); // title만 추출
        //console.log('tab2Fields:', tab2Fields); // 서버 로그에 출력 확인
        let tab3Fields = tab3Items.map(item => item.title);
        let tab4Fields = tab4Items.map(item => item.title);
        let tab5Fields = tab5Items.map(item => item.title);

        // 데이터 필드 추출 및 변환
        // const transformData = (data) => {
        //     return data.map(item => {
        //         const { _id, ...fields } = item; // _id를 제외하고 필드만 남김
        //         return Object.keys(fields);
        //     }).flat();
        // };

        //let tab1Fields = transformData(tab1Items);
        //let tab2Fields = transformData(tab2Items);
        //let tab3Fields = transformData(tab3Items);
        //let tab4Fields = transformData(tab4Items);
        //let tab5Fields = transformData(tab5Items);       
        
        
        // EJS 템플릿에 데이터 전달
        res.render('Dashboard', {
            Severity,
            Inspection_Items,
            system_info,
            files,
            tab1Items: tab1Fields,
            tab2Items: tab2Fields,
            tab3Items: tab3Fields,
            tab4Items: tab4Fields,
            tab5Items: tab5Fields,
            result_files
        });
        console.log(tab1Items)
    } catch (error) {
        console.error('Error fetching data:', error);
        res.status(500).send('Internal Server Error');
    }
});

  
app.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});

app.get('/test', (req, res) => {
    res.render('nav.ejs', {
    });
})
app.get('/register', async (req, res) => {
    res.render('register.ejs')
})

app.post('/register-action', async (req, res) => {
    const { username, password, email, serial } = req.body;

    // 빈 값 체크
    if (!username || !password || !email || !serial) {
        return res.status(400).send('모든 필드를 채워주세요.');
    }

    // 비밀번호 길이 체크
    if (password.length < 8) {
        return res.status(400).send('비밀번호는 최소 8자 이상이어야 합니다.');
    }

    // 중복 체크
    const existingUser = await db.collection('Users').findOne({ $or: [{ username }, { email }, { serial }] });
    if (existingUser) {
        return res.status(400).send('이미 사용 중인 사용자 이름, 이메일 또는 시리얼 번호입니다.');
    }

    // 비밀번호 해시화
    let hash = await bcrypt.hash(password, 10);

    // 사용자 정보 저장
    await db.collection('Users').insertOne({
        username: username,
        password: hash,
        email: email,
        serial: serial
    });

    // 세션이 있다면 제거 (로그인 후 세션에 대한 처리를 포함)
    if (req.session) {
        req.session.destroy(err => {
            if (err) {
                console.error('세션 제거 중 오류 발생:', err);
                return res.status(500).send('서버 오류');
            }
            // 로그인 페이지로 리다이렉트하면서 쿼리 문자열로 메시지 전달
            res.redirect('/login');
        });
    } else {
        // 세션이 없는 경우
        res.redirect('/login');
    }
});

app.get('/login', async (req, res) => {
    console.log(req.user)
    res.render('login.ejs')
})
app.post('/login-action', (req, res, next) => {
    passport.authenticate('local', (error, user, info) => {
        if (error) {
            return res.status(500).json({ error: 'Internal server error' });
        }
        if (!user) {
            return res.redirect('/login');
        }
        req.logIn(user, (err) => {
            if (err) {
                return res.status(500).json({ error: 'Login failed' });
            }
            return res.redirect('/');
        });
    })(req, res, next);
});
app.get('/logout', (req, res) => {
    req.session.destroy((err) => {
        if (err) {
            return res.status(500).send('로그아웃 중 오류가 발생했습니다.');
        }
        res.redirect('/login?message=로그아웃되었습니다.');
    });
});
app.get('/mypage',ensureAuthenticated, (req, res) => {
    let files = fs.readdirSync(ScriptFolder);
    res.render('mypage.ejs', {
        files: files,
    });
})

app.post('/severity_total', (req, res) => {
    const scriptOutput_severity = req.body;
    if (!scriptOutput_severity) {
        return res.status(400).send('No data received');
    }

    // 컬렉션 참조
    const collection = db.collection('Severity');

    collection.insertOne(scriptOutput_severity)
        .then(() => {
            res.send('Data inserted into the database');
        })
        .catch((dbErr) => {
            console.error(`Database insertion error: ${dbErr}`);
            res.status(500).send('Database Error');
        });
});

app.post('/Inspection_Items', (req, res) => {
    const Inspection_Items = req.body;
    if (!Inspection_Items) {
        return res.status(400).send('No data received');
    }

    // 컬렉션 참조
    const collection = db.collection('Inspection_Items');

    collection.insertOne(Inspection_Items)
        .then(() => {
            res.send('Data inserted into the database');
        })
        .catch((dbErr) => {
            console.error(`Database insertion error: ${dbErr}`);
            res.status(500).send('Database Error');
        });
});

app.post('/system_info', async (req, res) => {
    const systen_info = req.body;

    // 받은 데이터가 올바른지 확인
    if (!systen_info || !systen_info.hostname || !systen_info.date_time || !systen_info.info || !systen_info.release) {
        return res.status(400).send('Invalid data received');
    }

    try {
        // MongoDB 컬렉션 참조
        const collection = db.collection('system_info');

        // 데이터를 MongoDB에 삽입
        await collection.insertOne(systen_info);
        res.send('System info data inserted into the database');
    } catch (dbErr) {
        console.error('Database insertion error:', dbErr);
        res.status(500).send('Database Error');
    }
});

app.post('/upload', upload.array('result_files'), (req, res) => {
    res.redirect('/result_files');
});
  // Render uploaded files
app.get('/result_files', (req, res) => {
    fs.readdir(path.join(__dirname, 'uploads'), (err, result_files) => {
      if (err) {
        return res.status(500).send('Unable to scan directory');
      }
      res.render('Dashboard', { result_files: result_files });
    });
});

app.get('/download/:filename', (req, res) => {
    const { filename } = req.params;
    const filePath = path.join(ScriptFolder, filename);

    res.download(filePath, (err) => {
        if(err) {
            res.status(400).json({ message : "File Not Found"})
        }
    })
})
app.get('/result_download/:filename', (req, res) => {
    const { filename } = req.params;
    const filePath = path.join(result_ScriptFolder, filename);

    console.log('File path:', filePath); // 파일 경로를 콘솔에 출력

    res.download(filePath, (err) => {
        if (err) {
            console.error('Error downloading file:', err);
            res.status(400).json({ message: "File Not Found" });
        }
    });
});

// 파일만 삭제하는 함수
async function deleteAllFilesInFolder(folderPath) {
    try {
        // 폴더 내의 모든 파일 및 하위 디렉토리 가져오기
        const items = await fs.promises.readdir(folderPath, { withFileTypes: true });

        // 파일 및 디렉토리 삭제
        await Promise.all(items.map(async item => {
            const itemPath = path.join(folderPath, item.name);
            if (item.isFile()) {
                // 파일 삭제
                await fs.promises.unlink(itemPath);
            } else if (item.isDirectory()) {
                // 디렉토리 재귀적으로 삭제
                await deleteAllFilesInFolder(itemPath);
                await fs.promises.rmdir(itemPath); // 빈 디렉토리 삭제
            }
        }));
    } catch (error) {
        console.error(`Error deleting files in folder: ${error.message}`);
        throw error; // 에러를 상위로 전달
    }
}

app.get('/clear_collections', async (req, res) => {
    // 컬렉션을 삭제하는 비동기 함수
    async function clearCollections() {
        const collections = [
            'Severity',
            'Inspection_Items',
            'system_info',
            'Account_Management',
            'Files_Directory_Management',
            'Service_Management',
            'Patch_Management',
            'Log_Management'
        ];

        try {
            await Promise.all(collections.map(name => {
                const collection = db.collection(name);
                return collection.deleteMany({});
            }));
        } catch (dbErr) {
            console.error(`Failed to delete documents: ${dbErr.message}`);
            throw new Error('Failed to delete documents');
        }
    }

    // 파일을 삭제하는 비동기 함수
    async function clearFiles() {
        try {
            await deleteAllFilesInFolder(path.join(__dirname, 'uploads'));
        } catch (error) {
            console.error(`Failed to delete all files: ${error.message}`);
            throw new Error('Failed to delete all files');
        }
    }

    try {
        // 데이터베이스 컬렉션과 파일을 순차적으로 삭제
        await clearCollections();
        await clearFiles();
        res.redirect('/');
    } catch (error) {
        res.status(500).json({ error: error.message });
    }

});


app.post('/Account_Management', async (req, res) => {
    const Account_Management = req.body;

    // 필드를 가져오는 함수
    const getFieldValue = (fieldName) => {
        // Account_Management 객체에서 특정 필드 값을 반환합니다.
        return Account_Management[fieldName];
    };

    let processed = false;
    let responseSent = false;

    try {
        // 1부터 72까지 반복하며 처리
        for (let i = 1; i <= 72; i++) {
            const key = `u${i}_Account_Management`;
            
            // 필드 값이 존재하는지 확인
            const fieldValue = getFieldValue(key);
            
            if (fieldValue) {
                const mapping = dataMapping[key];

                if (mapping) {
                    const processedData = {
                        title: mapping.title,
                        inspection: mapping.inspection,
                        threat: mapping.threat,
                        good: mapping.good,
                        bad: mapping.bad,
                        solution: mapping.solution
                    };

                    try {
                        const collection = db.collection('Account_Management');
                        await collection.insertOne(processedData);
                        processed = true;
                    } catch (dbErr) {
                        console.error('Database insertion error:', dbErr);
                        if (!responseSent) {
                            responseSent = true;
                            return res.status(500).send('Database Error');
                        }
                    }
                }
            }
        }

        if (!responseSent) {
            if (processed) {
                res.send('System info data inserted into the database');
            } else {
                res.status(400).send('No valid data found to process');
            }
        }
    } catch (error) {
        console.error('Error processing request:', error);
        if (!responseSent) {
            res.status(500).send('Internal Server Error');
        }
    }
});


app.post('/Files_Directory_Management', async (req, res) => {
    const Files_Directory_Management = req.body;

    // 필드를 가져오는 함수
    const getFieldValue = (fieldName) => {
        // Files_Directory_Management 객체에서 특정 필드 값을 반환합니다.
        return Files_Directory_Management[fieldName];
    };

    let processed = false;
    let responseSent = false;

    try {
        // 1부터 72까지 반복하며 처리
        for (let i = 1; i <= 72; i++) {
            const key = `u${i}_Files_Directory_Management`;
            
            // 필드 값이 존재하는지 확인
            const fieldValue = getFieldValue(key);
            
            if (fieldValue) {
                const mapping = dataMapping[key];

                if (mapping) {
                    const processedData = {
                        title: mapping.title,

                    };

                    try {
                        const collection = db.collection('Files_Directory_Management');
                        await collection.insertOne(processedData);
                        processed = true;
                    } catch (dbErr) {
                        console.error('Database insertion error:', dbErr);
                        if (!responseSent) {
                            responseSent = true;
                            return res.status(500).send('Database Error');
                        }
                    }
                }
            }
        }

        if (!responseSent) {
            if (processed) {
                res.send('System info data inserted into the database');
            } else {
                res.status(400).send('No valid data found to process');
            }
        }
    } catch (error) {
        console.error('Error processing request:', error);
        if (!responseSent) {
            res.status(500).send('Internal Server Error');
        }
    }
});
app.post('/Service_Management', async (req, res) => {
    const Service_Management = req.body;

    // 필드를 가져오는 함수
    const getFieldValue = (fieldName) => {
        // Service_Management 객체에서 특정 필드 값을 반환합니다.
        return Service_Management[fieldName];
    };

    let processed = false;
    let responseSent = false;

    try {
        // 1부터 72까지 반복하며 처리
        for (let i = 1; i <= 72; i++) {
            const key = `u${i}_Service_Management`;
            
            // 필드 값이 존재하는지 확인
            const fieldValue = getFieldValue(key);
            
            if (fieldValue) {
                const mapping = dataMapping[key];

                if (mapping) {
                    const processedData = {
                        title: mapping.title,
                        inspection: mapping.inspection,
                        threat: mapping.threat,
                        good: mapping.good,
                        bad: mapping.bad,
                        solution: mapping.solution
                    };

                    try {
                        const collection = db.collection('Service_Management');
                        await collection.insertOne(processedData);
                        processed = true;
                    } catch (dbErr) {
                        console.error('Database insertion error:', dbErr);
                        if (!responseSent) {
                            responseSent = true;
                            return res.status(500).send('Database Error');
                        }
                    }
                }
            }
        }

        if (!responseSent) {
            if (processed) {
                res.send('System info data inserted into the database');
            } else {
                res.status(400).send('No valid data found to process');
            }
        }
    } catch (error) {
        console.error('Error processing request:', error);
        if (!responseSent) {
            res.status(500).send('Internal Server Error');
        }
    }
});
app.post('/Patch_Management', async (req, res) => {
    const Patch_Management = req.body;

    // 필드를 가져오는 함수
    const getFieldValue = (fieldName) => {
        // Patch_Management 객체에서 특정 필드 값을 반환합니다.
        return Patch_Management[fieldName];
    };

    let processed = false;
    let responseSent = false;

    try {
        // 1부터 72까지 반복하며 처리
        for (let i = 1; i <= 72; i++) {
            const key = `u${i}_Patch_Management`;
            
            // 필드 값이 존재하는지 확인
            const fieldValue = getFieldValue(key);
            
            if (fieldValue) {
                const mapping = dataMapping[key];

                if (mapping) {
                    const processedData = {
                        title: mapping.title,
                        inspection: mapping.inspection,
                        threat: mapping.threat,
                        good: mapping.good,
                        bad: mapping.bad,
                        solution: mapping.solution
                    };

                    try {
                        const collection = db.collection('Patch_Management');
                        await collection.insertOne(processedData);
                        processed = true;
                    } catch (dbErr) {
                        console.error('Database insertion error:', dbErr);
                        if (!responseSent) {
                            responseSent = true;
                            return res.status(500).send('Database Error');
                        }
                    }
                }
            }
        }

        if (!responseSent) {
            if (processed) {
                res.send('System info data inserted into the database');
            } else {
                res.status(400).send('No valid data found to process');
            }
        }
    } catch (error) {
        console.error('Error processing request:', error);
        if (!responseSent) {
            res.status(500).send('Internal Server Error');
        }
    }
});
app.post('/Log_Management', async (req, res) => {
    const Log_Management = req.body;

    // 필드를 가져오는 함수
    const getFieldValue = (fieldName) => {
        // Log_Management 객체에서 특정 필드 값을 반환합니다.
        return Log_Management[fieldName];
    };

    let processed = false;
    let responseSent = false;

    try {
        // 1부터 72까지 반복하며 처리
        for (let i = 1; i <= 72; i++) {
            const key = `u${i}_Log_Management`;
            
            // 필드 값이 존재하는지 확인
            const fieldValue = getFieldValue(key);
            
            if (fieldValue) {
                const mapping = dataMapping[key];

                if (mapping) {
                    const processedData = {
                        title: mapping.title,
                        inspection: mapping.inspection,
                        threat: mapping.threat,
                        good: mapping.good,
                        bad: mapping.bad,
                        solution: mapping.solution
                    };

                    try {
                        const collection = db.collection('Log_Management');
                        await collection.insertOne(processedData);
                        processed = true;
                    } catch (dbErr) {
                        console.error('Database insertion error:', dbErr);
                        if (!responseSent) {
                            responseSent = true;
                            return res.status(500).send('Database Error');
                        }
                    }
                }
            }
        }

        if (!responseSent) {
            if (processed) {
                res.send('System info data inserted into the database');
            } else {
                res.status(400).send('No valid data found to process');
            }
        }
    } catch (error) {
        console.error('Error processing request:', error);
        if (!responseSent) {
            res.status(500).send('Internal Server Error');
        }
    }
});